\documentclass[a4paper]{article}

\newcommand{\defun}[2] {$$ #1\ :=\ #2$$}
\newcommand{\defpred}[2]{ $$ #1\ \equiv\ #2$$}
\newcommand{\caseif}[2] {#1 & \text{if } #2 \\}
\newcommand{\caseow}[1] {#1 & \text{otherwise }}
\newcommand{\MOD} {\ \text{mod}\ } 

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}


\title{Tic Tac Toe}

\author{Nelson Rushton, Qianji Zheng, and Vu Phan}

\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This program plays tic tac toe. The game begins with an empty grid and it being x's turn to move. When an empty cell is clicked, the player whose turn it occupies that cell and it becomes the other player's turn, until the game is over. When the game is over a message is displayed giving the result of the  game. The player can press the 'reset' button at any time to restart the game.

\end{abstract}

\section{Data Model}

A {\it player} is either `x or `o. In this program, the variable $p$ will range over players.

\bigskip\noindent
A {\it cell} is an integer in $\{1..9\}$. 

\defun{Cells}{\{1..9\}}

\noindent
In this program, the variable $c$ will range over cells. Cells represent squares on the tic tac toe board as pictured below:
\bigskip\bigskip


\begin{tabular}{c|c|c}
$1$  &  $2$    &   $3$  \\
\hline
$4$ &  $5$    &   $6$  \\
\hline
$7$ &  $8$    &   $9$  
\end{tabular}

\bigskip\noindent
A {\it move} is a pair $(p,c)$ where $p$ is a player and $c$ is a cell. The move $(p,c)$ represents a move by player $p$ in cell $c$. In this program, the variable $m$ will range over moves.

\bigskip\noindent
A {\it state} is a set of moves, thought of as the set of moves made far in the game. In this program, the variable $S$ will range over states.

\bigskip\noindent
The program references the constant symbols $currentState$, $clicked$, $clickX$, and $clickY$, which are of types $state$, $Bool$, $Int$, and $Int$, respectively. 

\pagebreak

\section{Game Rules}
\label{sec:theory}

This section defines the rules of tic-tac-toe. The top level definitions of this section are as follows:
\begin{itemize}
\item $initialState$ is the initial state of the game.
\item $legalMove: move\rightarrow Bool$ --- $legalMove(m)$ means that move $m$ is legal in the current state.
\item $outcome:move \rightarrow state$ --- If  $m$ is a legal move in the current state, then $outcome(m)$ is the state that will result from making that move.
\item $threeInRow:player \rightarrow Bool$ --- $threeInRow(p)$ means player $p$ has three in a row. 
\item $boardFull$ is a flag indicating that the board is full.
\end{itemize}

\bigskip\noindent
Since the state of the game is the set of moves that have been made, the initial state is simply the empty set.

\defun{initialState} {\emptyset}

\bigskip\noindent
Player $p$ {\it occupies} cell $c$ if the move $(p,c)$ is a member of $currentState$.

\defpred{occupies(p,c)}{\ (p,c) \in currentState}

\bigskip\noindent
Cell $c$ is {\it occupied} if it is occupied by $`x$ or by $`o$.

\defpred {occupied(c)} {\ occupies(`x,c)\ \vee\ occupies(`o,c)}


\bigskip\noindent
A {\it row} is a set of three cells that form three in a row either horizontally, vertically, or diagonally. We will write {\it rows} for the set of all rows.

\begin{align*}
rows  := \ & hRows \cup vRows \cup diagonals \ \ \text{where} \\  
    \smallskip
    hRows &= \{\{1,2,3\},\{4,5,6\},\{7,8,9\}\}, \\
    vRows &= \{\{1,4,7\},\{2,5,8\},\{3,6,9\}\}, \\
    diagonals&= \{\{1,5,9\},\{3,5,7\}\}
\end{align*}

\bigskip\noindent
Player $p$ {\it fills} row $r$ if he or she occupies every cell in $r$.

\defpred{fills(p,r)}{\ \forall c\in r.\ occupies(p,c)}

\bigskip\noindent
We write $threeInRow(p)$ if player $p$ fills a row.

\defpred{threeInRow(p)} {\ \exists r\in rows.\ fills(p,r)}

\bigskip\noindent
The board is full if all 9 cells are occupied. 

\defpred{boardFull}{\ |currentState| = 9}

\bigskip\noindent
The game is over if either the board is full,  $`x$ has  three in a row, or $`o$ has three in a row.

\defpred{gameOver} {\ boardFull\ \vee\ threeInRow(`x)\ \vee\ threeInRow(`o)}

\bigskip\noindent
$playerToMove$ is $`x$ if an even number of moves have been made, and $`o$ otherwise,

\defun{playerToMove}
{\begin{cases}
    \caseif{`x}{even(|currentState|)}
    \caseow{`o}
 \end{cases}
}
where, of course, an integer is {\it even} iff it is divisible by 2:

\defpred{even(n)}{\ n \MOD 2 = 0}

\bigskip\noindent
It is legal to move in cell $c$ if the game is not over and $c$ is not occupied.

\defpred {legalToMoveIn(c)} {\ \lnot gameOver,\ \lnot occupied(c)}


\bigskip\noindent
$moveMade$ means that a move is being made in some cell. The predicate $moveMadeIn:Cell\rightarrow Bool$ is defined in Section 3 (Mouse Input). 

\defpred{moveMade}{\exists c \in Cells.\ moveMadeIn(c)}


\bigskip\noindent
If $moveMade$ holds, then $move$ is a singleton set whose only
member is the move that is being made.

\defun{move}
{\{(playerToMove,c)\ |\ c \in Cells,\ moveMadeIn(c)\}}

\bigskip\noindent
The last two definitions give  preconditions and effects of actions in the game. The actions $`restart$ and $`nil$ are always possible. A move is possible if it satisfies the relation $legalMove$.

\bigskip\noindent
If the makes a move, it is added to the current state. If he restarts the game, it returns to its initial state. Otherwise, the state does not change.

\defun{nextState}
{\begin{cases}
\caseif{currentState \cup move} {moveMade}
\caseif{initialState} {restart}
\caseow{currentState}
\end{cases}
}




\section{Video Output}

This section defines the video output to the screen as a function of state. 

\end{document}



======================================================================
VIDEO OUTPUT
======================================================================

The default color used in this game is BLACK
/$
BLACK := color(0, 0, 0)
WHITE := color(255, 255, 255)
BLUE := color(0, 0, 255)
GREEN := color(0, 255, 0)
RED := color(255, 0, 0)
$/

----------------------------------------------------------------------

This section defines the *display* function, specifying the images to display on the screen in each game state. The  *grid* consists is a set of four line segments that make up the tic tac toe playing area.
/$
gridDisplay := {L1,L2,L3,L4} where
    L1 = segment(point(200,700),point(200,400),BLACK) &
    L2 = segment(point(300,700),point(300,400),BLACK) &
    L3 = segment(point(100,600),point(400,600),BLACK) &
    L4 = segment(point(100,500),point(400,500),BLACK)
$/

The default font size for displayed text in this program is 36.
/$
fontSize := 36
$/

*centerX(c)* and *centerY(c)* are the x and y coordinates of the center of cell c, respectively.
/$
centerX(c) := 150 + 100 * ((c-1) mod 3)
centerY(c) := 650 - 100 * (floor((c-1)/3))
$/

*cellDisplay(c)* is a display of a text character "x" or an "o" in cell c, or the empty display, respectively in case cell c is occupied by `x, occupied by `o, or not occupied in the current game state.
/$
xImage(c) := text("x", point(centerX(c), centerY(c)), fontSize, BLUE)
oImage(c) := text("o", point(centerX(c), centerY(c)), fontSize, GREEN)
cellDisplay(c) :=
    {xImage(c)} if (`x, c) in CURRENT_STATE;
    {oImage(c)} if (`o, c) in CURRENT_STATE;
    {} otherwise
$/

*cellDisplays* is the set of all images of x's and o's on the board in the current state.
/$

cellDisplays := U[c in gameBoard] cellDisplay(c)
$/

________________

If the game is not over, *currentPlayerDisplay* is a text in the upper left hand region of the game window indicating the player to move, either "play x's turn" or "play o's turn",
/$
currentPlayerDisplay :=
    {text("x's turn",point(100,750),fontSize,BLACK)} if playerToMove = `x;
    {text("o's turn",point(100,750),fontSize,BLACK)} otherwise
$/

The *restart button* consists of a rectangle around a "restart" text, displayed in the upper right region of the screen. Formally, it is a set of four line segments and a text.
/$
restartLeft := 350
restartRight := 550
restartBottom := 725
restartTop := 775
restartBottomLeftPoint := point(restartLeft, restartBottom)
restartBottomRightPoint := point(restartRight, restartBottom)
restartTopLeftPoint := point(restartLeft, restartTop)
restartTopRightPoint := point(restartRight, restartTop)
mid(a, b) := (a + b) / 2
restartMidX := mid(restartLeft, restartRight)
restartMidY := mid(restartBottom, restartTop)
restartButton := {A1,A2,A3,A4,txt} where
    A1 = segment(restartBottomLeftPoint,restartBottomRightPoint,BLACK) &
    A2 = segment(restartTopLeftPoint,restartTopRightPoint,BLACK) &
    A3 = segment(restartBottomLeftPoint,restartTopLeftPoint,BLACK) &
    A4 = segment(restartBottomRightPoint,restartTopRightPoint,BLACK) &
    txt = text("restart",point(restartMidX,restartMidY),fontSize,BLACK)
$/

If the game is over, *gameResultDisplay* is a display in the upper left region of the screen telling the outcome of the game, either "x won", "o won", or "cat got it"
/$
gameResultDisplay :=
    {text("x won",point(200,750),fontSize,BLUE)} if threeInRow(`x);
    {text("o won",point(200,750),fontSize,GREEN)} if threeInRow(`o);
    {text("cat got it",point(200,750),fontSize,RED)} otherwise
$/

The *display* is the screen display for the current game state. The grid, cell displays, and restart button are always displayed. Additionally, the display includes the game results if the game is over, and the player to move if the game is not over.
/$
images :=
    gameOverDisplay if gameOver;
    inPlayDisplay otherwise where
        alwaysDisplay = gridDisplay U cellDisplays U restartButton &
        inPlayDisplay = alwaysDisplay U currentPlayerDisplay &
        gameOverDisplay = alwaysDisplay U gameResultDisplay
$/

======================================================================
MOUSE INPUT
======================================================================

This section defines *update*, which specifies the program's response to mouse input. The variable *pt* will vary over points.

*xMin(c)*, *xMax(c)*, *yMin(c)*, and *yMax(c)* denote the graphical boundaries of cell c, in the obvious manner.
/$
xMin(c) := 100+100*((c-1) mod 3)
xMax(c) := 200+100*((c-1) mod 3)
yMin(c) := 600-100*(floor((c-1)/3))
yMax(c) := 700-100*(floor((c-1)/3))
$/

cellClicked(c) means that cell c has been clicked.
/$
cellClicked(c) iff
    CLICKED &
    CLICK_X > xMin(c) & CLICK_X < xMax(c) &
    CLICK_Y > yMin(c) & CLICK_Y < yMax(c)
$/

*restartClicked* means that the most recent mouse click is inside the region of the play again button.
/$
restartClicked :=
    CLICKED &
    CLICK_X > restartLeft & CLICK_X < restartRight &
    CLICK_Y > restartBottom & CLICK_Y < restartTop
$/

________________

*moveMade(c)* means that cell c has been clicked and the player to move may legally move there.
/$
moveMadeIn(c) iff cellClicked(c) & legalToMoveIn(c)

newState :=
    initialState if restartClicked;
    CURRENT_STATE U movesMade otherwise
$/
